<?php

declare(strict_types=1);

/*
 * This file has been auto generated by Jane,
 *
 * Do no edit it directly.
 */

namespace Pezos\Generated\Dal;

class Client extends Runtime\Client\Client
{
    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\HealthGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getHealth(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetHealth(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getLastProcessedLevel(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLastProcessedLevel(), $fetch);
    }

    /**
     * Return the accepted commitment associated to the given slot index and published at the given level.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getLevelsByInt32SlotsByIntCommitment(string $int32, string $int, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLevelsByInt32SlotsByIntCommitment($int32, $int), $fetch);
    }

    /**
     * Retrieve the content of the slot whose id is given.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getLevelsByInt32SlotsByIntContent(string $int32, string $int, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLevelsByInt32SlotsByIntContent($int32, $int), $fetch);
    }

    /**
     * Fetch slot as list of pages.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getLevelsByInt32SlotsByIntPages(string $int32, string $int, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLevelsByInt32SlotsByIntPages($int32, $int), $fetch);
    }

    /**
     * Compute the proof associated with a page of a given slot.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getLevelsByInt32SlotsByIntPagesByIntProof(string $int32, string $int, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLevelsByInt32SlotsByIntPagesByIntProof($int32, $int), $fetch);
    }

    /**
     * Fetch shard as bytes.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getLevelsByInt32SlotsByIntShardsByIntContent(string $int32, string $int, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLevelsByInt32SlotsByIntShardsByIntContent($int32, $int), $fetch);
    }

    /**
     * Return the status for the given slot.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getLevelsByInt32SlotsByIntStatus(string $int32, string $int, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLevelsByInt32SlotsByIntStatus($int32, $int), $fetch);
    }

    /**
     * Connect to a new peer.
     *
     * @param mixed|null $requestBody
     * @param array      $queryParameters {
     *
     * @var string $timeout A span of time in seconds
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function postP2pConnect($requestBody = null, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostP2pConnect($requestBody, $queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\P2pGossipsubBackoffsGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getP2pGossipsubBackoffs(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetP2pGossipsubBackoffs(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\P2pGossipsubConnectionsGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getP2pGossipsubConnections(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetP2pGossipsubConnections(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\P2pGossipsubFanoutGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getP2pGossipsubFanout(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetP2pGossipsubFanout(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\P2pGossipsubMeshGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getP2pGossipsubMesh(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetP2pGossipsubMesh(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\P2pGossipsubMessageCacheGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getP2pGossipsubMessageCache(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetP2pGossipsubMessageCache(), $fetch);
    }

    /**
     * When the 'all' flag is given, get an association list between each topic subscribed to by the connected peers and the remote peers subscribed to that topic. If the 'all' flag is not given, then restrict the output to the topics this peer is subscribed to.
     *
     * @param array $queryParameters {
     *
     * @var string $all
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\P2pGossipsubPkhsPeersGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getP2pGossipsubPkhsPeers(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetP2pGossipsubPkhsPeers($queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\P2pGossipsubReconnectionDelaysGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getP2pGossipsubReconnectionDelays(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetP2pGossipsubReconnectionDelays(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\P2pGossipsubScoresGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getP2pGossipsubScores(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetP2pGossipsubScores(), $fetch);
    }

    /**
     * When the 'all' flag is given, get an association list between each public key hash part of a topic subscribed to by the connected peers and the remote peers subscribed to such topics. If the 'all' flag is not given, then restrict the output to the topics this peer is subscribed to.
     *
     * @param array $queryParameters {
     *
     * @var string $all
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\P2pGossipsubSlotIndexesPeersGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getP2pGossipsubSlotIndexesPeers(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetP2pGossipsubSlotIndexesPeers($queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\P2pGossipsubTopicsGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getP2pGossipsubTopics(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetP2pGossipsubTopics(), $fetch);
    }

    /**
     * When the 'all' flag is given, get an association list between each topic subscribed to by the connected peers and the remote peers subscribed to that topic. If the 'all' flag is not given, then restrict the output to the topics this peer is subscribed to.
     *
     * @param array $queryParameters {
     *
     * @var string $all
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\P2pGossipsubTopicsPeersGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getP2pGossipsubTopicsPeers(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetP2pGossipsubTopicsPeers($queryParameters), $fetch);
    }

    /**
     * By default, get the list of known peers. When the 'connected' flag is given, then only get the connected peers.
     *
     * @param array $queryParameters {
     *
     * @var string $connected
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\P2pPeersGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getP2pPeers(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetP2pPeers($queryParameters), $fetch);
    }

    /**
     * Get info of the requested peer.
     *
     * @param string $peerId A cryptographic node identity (Base58Check-encoded)
     * @param string $fetch  Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\P2pPeersByIdPeerIdGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getP2pPeersByIdByPeerId(string $peerId, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetP2pPeersByIdByPeerId($peerId), $fetch);
    }

    /**
     * Change the permissions of a given peer. With `{acl: ban}`: blacklist the given peer and remove it from the whitelist if present. With `{acl: open}`: removes the peer from the blacklist and whitelist. With `{acl: trust}`: trust the given peer permanently and remove it from the blacklist if present. The peer cannot be blocked (but its host IP still can). In all cases, the updated information for the peer is returned. If input is omitted, this is equivalent to using the `GET` version of this RPC.
     *
     * @param string $peerId A cryptographic node identity (Base58Check-encoded)
     * @param string $fetch  Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\P2pPeersByIdPeerIdPatchResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function patchP2pPeersByIdByPeerId(string $peerId, ?Model\P2pPeersByIdPeerIdPatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchP2pPeersByIdByPeerId($peerId, $requestBody), $fetch);
    }

    /**
     * Disconnect from a peer.
     *
     * @param string $peerId          A cryptographic node identity (Base58Check-encoded)
     * @param array  $queryParameters {
     *
     * @var string $wait
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function deleteP2pPeersDisconnectByPeerId(string $peerId, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteP2pPeersDisconnectByPeerId($peerId, $queryParameters), $fetch);
    }

    /**
     * Get list of known peers and their corresponding info.
     *
     * @param array $queryParameters {
     *
     * @var string $connected
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\P2pPeersInfoGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getP2pPeersInfo(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetP2pPeersInfo($queryParameters), $fetch);
    }

    /**
     * By default, get the list of known points. When the 'connected' flag is given, only get the connected points.
     *
     * @param array $queryParameters {
     *
     * @var string $connected
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\P2pPointsGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getP2pPoints(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetP2pPoints($queryParameters), $fetch);
    }

    /**
     * Get info of the requested point.
     *
     * @param string $point a network point (ipv4:port or [ipv6]:port)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\P2pPointsByIdPointGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getP2pPointsByIdByPoint(string $point, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetP2pPointsByIdByPoint($point), $fetch);
    }

    /**
     * Disconnect from a point.
     *
     * @param string $point           a network point (ipv4:port or [ipv6]:port)
     * @param array  $queryParameters {
     *
     * @var string $wait
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function deleteP2pPointsDisconnectByPoint(string $point, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteP2pPointsDisconnectByPoint($point, $queryParameters), $fetch);
    }

    /**
     * By default, get the list of known points and their corresponding info. When the 'connected' flag is given, then only get the connected points.
     *
     * @param array $queryParameters {
     *
     * @var string $connected
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\P2pPointsInfoGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getP2pPointsInfo(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetP2pPointsInfo($queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getProfile(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetProfile(), $fetch);
    }

    /**
     * Update the list of profiles tracked by the DAL node. Note that it does not take the bootstrap profile as it is incompatible with other profiles.
     *
     * @param mixed|null $requestBody
     * @param string     $fetch       Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function patchProfile($requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchProfile($requestBody), $fetch);
    }

    /**
     * Return the shard indexes assigned to the given public key hash at the given level.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getProfilesByPkhAttestedLevelsByInt32AssignedShardIndices(string $pkh, string $int32, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetProfilesByPkhAttestedLevelsByInt32AssignedShardIndices($pkh, $int32), $fetch);
    }

    /**
     * Return the currently attestable slots at the given attested level by the given public key hash. A slot is attestable at level [l] if it is published at level [l - attestation_lag] and *all* the shards assigned at level [l] to the given public key hash are available in the DAL node's store.
     *
     * @param string $pkh   A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function getProfilesByPkhAttestedLevelsByInt32AttestableSlot(string $pkh, string $int32, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetProfilesByPkhAttestedLevelsByInt32AttestableSlot($pkh, $int32), $fetch);
    }

    /**
     * Returns the protocol parameters as known by the DAL node. An optional 'level' argument can specify for which level to retrieve them.
     *
     * @param array $queryParameters {
     *
     * @var string $level
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ProtocolParametersGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getProtocolParameter(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetProtocolParameter($queryParameters), $fetch);
    }

    /**
     * For a given published level, return all the traps known by the node. Optional arguments allow to restrict the output to a given delegate or slot index.
     *
     * @param array $queryParameters {
     *
     * @var string $delegate A Secp256k1 of a Ed25519 public key hash (Base58Check-encoded)
     * @var string $slot_index
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\PublishedLevelsInt32KnownTrapsGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getPublishedLevelsByInt32KnownTraps(string $int32, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetPublishedLevelsByInt32KnownTraps($int32, $queryParameters), $fetch);
    }

    /**
     * Post a slot to the DAL node, computes its commitment and commitment proof, then computes the correspoding shards with their proof. The result of this RPC can be directly used to publish a slot header. If the sent data is smaller than the size of a DAL slot, it is padded with the character provided as padding query parameter (defaults to \000). If the slot_index query parameter is provided, the DAL node checks that its profile allows to publish data on the given slot index.
     *
     * @param mixed|null $requestBody
     * @param array      $queryParameters {
     *
     * @var string $padding
     * @var string $slot_index
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\SlotsPostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function postSlot($requestBody = null, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostSlot($requestBody, $queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VersionGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function getVersion(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVersion(), $fetch);
    }

    public static function create($httpClient = null, array $additionalPlugins = [], array $additionalNormalizers = [])
    {
        if (null === $httpClient) {
            $httpClient = \Http\Discovery\Psr18ClientDiscovery::find();
            $plugins = [];
            if (count($additionalPlugins) > 0) {
                $plugins = array_merge($plugins, $additionalPlugins);
            }
            $httpClient = new \Http\Client\Common\PluginClient($httpClient, $plugins);
        }
        $requestFactory = \Http\Discovery\Psr17FactoryDiscovery::findRequestFactory();
        $streamFactory = \Http\Discovery\Psr17FactoryDiscovery::findStreamFactory();
        $normalizers = [new \Symfony\Component\Serializer\Normalizer\ArrayDenormalizer(), new Normalizer\JaneObjectNormalizer()];
        if (count($additionalNormalizers) > 0) {
            $normalizers = array_merge($normalizers, $additionalNormalizers);
        }
        $serializer = new \Symfony\Component\Serializer\Serializer($normalizers, [new \Symfony\Component\Serializer\Encoder\JsonEncoder(new \Symfony\Component\Serializer\Encoder\JsonEncode(), new \Symfony\Component\Serializer\Encoder\JsonDecode(['json_decode_associative' => true]))]);

        return new static($httpClient, $requestFactory, $serializer, $streamFactory);
    }
}
